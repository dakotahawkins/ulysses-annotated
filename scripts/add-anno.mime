// -*- mode: js -*-

// this is a chaiscript file, but there is no wide syntax highlighting
// support for it yet, and js-mode is a close approximation.

def parseargs() {
    var parser = args_parser();
    parser.string_opt("d,date", "date for the last_updated field")
    parser.string_opt("anno_path", "path of the downloaded annotations");
    parser.string_opt("infile", "path of the input file");
    parser.string_opt("outfile", "path of the output file");
    parser.string_opt("colour_outfile", "path of the colour coded output file");
    return parser.parse();
}

global basepath;

global chapters = [
    "/index.php-telem.htm",
    "/index.php-nestor.htm",
    "/index.php-proteus.htm",
    "/index.php-calypso.htm",
    "/index.php-lotus.htm",
    "/index.php-hades.htm",
    "/index.php-aeolus.htm",
    "/index.php-lestry.htm",
    "/index.php-scylla.htm",
    "/index.php-wrocks.htm",
    "/index.php-sirens.htm",
    "/index.php-cyclops.htm",
    "/index.php-nausicaa.htm",
    "/index.php-oxen.htm",
    "/index.php-circe.htm",
    "/index.php-eumaeus.htm",
    "/index.php-ithaca.htm",
    "/index.php-penelope.htm"
]

global colour_files = [
    "/scripts/swap/aeolus.js",
    "/scripts/swap/calypso.js",
    "/scripts/swap/circe.js",
    "/scripts/swap/cyclops.js",
    "/scripts/swap/eumaeus.js",
    "/scripts/swap/hades.js",
    "/scripts/swap/ithaca.js",
    "/scripts/swap/lestry.js",
    "/scripts/swap/lotus.js",
    "/scripts/swap/nausicaa.js",
    "/scripts/swap/nestor.js",
    "/scripts/swap/oxen.js",
    "/scripts/swap/penelope.js",
    "/scripts/swap/proteus.js",
    "/scripts/swap/scylla.js",
    "/scripts/swap/sirens.js",
    "/scripts/swap/telem.js",
    "/scripts/swap/wrocks.js"
]

global pagebreak = "<p class=\"pagebreak\"></p>";

def parse_colours() {
    var colours = Map();
    var exp_items = 0;
    for (var chapter = 0; chapter < 18; ++chapter) {
	var b = buffer(basepath+colour_files[chapter]);
	b.find("Remove Highlighting");
	b.narrow_to_block();
	while(b.find("getElementById('") >= 0) {
	    b.set_mark();
	    b.goto_pos(b.find("')"));
	    var note_name = to_string(b.copy());

	    b.goto_pos(b.find("#"));
	    b.set_mark();
	    b.goto_pos(b.find("'"));
	    var colour = to_string(b.copy());
	    
	    colours[note_name] = colour;
//	    print("'" + note_name + "' -> '" + colour + "'");
	    exp_items += 1;
	}
    }
//    print("exp_items: " + to_string(exp_items) + "; items: " + to_string(colours.size()));
    return colours;
}

def join_repeated_links(b, pattern, to_paste) {
    b.start_of_buffer();

    var rep_pos = b.find_fuzzy(pattern);
    while(rep_pos >= 0) {
	b.goto_pos(b.rfind("href=\""));
	b.set_mark();
	b.goto_pos(b.find("\""));
	var url_left = b.copy();

	b.goto_pos(rep_pos);

	b.find("href=\"");
	b.set_mark();
	b.goto_pos(b.find("\""));
	var url_right = b.copy();

	if (url_left == url_right) {
	    // print("repeated link: " + b.get_name() + ": " + url_left)
	    b.goto_pos(rep_pos);
	    b.set_mark();
	    b.find("<a");
	    b.find(">");
	    b.erase_region();
	    b.paste(to_paste);
	}

	rep_pos = b.find_fuzzy(pattern);
    }
}

def join_repeated_italics(b) {
    b.start_of_buffer();

    var rep_pos = b.find_fuzzy("</i> <i>");
    while(rep_pos >= 0) {
	b.set_mark();
	b.goto_pos(rep_pos);
	b.erase_region();
	b.paste(" ");

	rep_pos = b.find_fuzzy("</i> <i>");
    }
}

// first stage clean up
def fix_basics(b) {
    b.find("<p class=\"newchapter\">");
    var main_pos = b.get_pos();

    b.goto_pos(main_pos); b.replace("'",         "’");
    b.goto_pos(main_pos); b.replace(" <br />",   "");
    b.goto_pos(main_pos); b.replace("<br />",    " ");
    b.goto_pos(main_pos); b.replace(" </i>",     "</i>");
    b.goto_pos(main_pos); b.replace("</i>!",     "!</i>");
    b.goto_pos(main_pos); b.replace("em>",       "i>");
    b.goto_pos(main_pos); b.replace("<a/>",      "</a>");
    b.goto_pos(main_pos); b.replace("</a<",      "</a>");
    b.goto_pos(main_pos); b.replace("</i>\n<i>", "\n");
    b.goto_pos(main_pos); b.replace("</i> \n<i>", "\n");
    b.goto_pos(main_pos); b.replace("&nbsp;",    "");
    b.goto_pos(main_pos); b.replace("&eacute;",  "é");
    b.goto_pos(main_pos); b.replace("&Eacute;",  "É");
    b.goto_pos(main_pos); b.replace("&agrave;",  "à");
    b.goto_pos(main_pos); b.replace("&egrave;",  "è");
    b.goto_pos(main_pos); b.replace("&uuml;",    "ü");
    b.goto_pos(main_pos); b.replace("&#8212;",   "&mdash;");

    b.goto_pos(main_pos);
    while(b.find("<span class=\"page\" ") >= 0) {
	b.rfind("<span class=\"page\" ");
	b.set_mark();
	b.find("</span>");
	b.erase_region();
    }
}

def fix_telem(b) {
     b.replace("bowl of bitter waters.", "bowl of bitter waters.</a>", 1);
     b.replace("et unam sanctam catholicam</i></a><a id=\"010115creed1\" class=\"box-images\" href=\"notes/010115creed.htm\"><i> et apostolicam\necclesiam</i></a>:",
  	      "et unam sanctam catholicam et apostolicam ecclesiam:</i></a>", 1);
}

def fix_proteus(b) {
    b.replace("href=\"notes/030022chaussons.htm\">vous savez ah, oui!</i></a>",
	      "href=\"notes/030022chaussons.htm\"><i>vous savez ah, oui!</i></a>", 1);
}

def fix_nausicaa(b) {
    b.replace("<i>Leah,</i></a> <i>Lily of Killarney.</i>", "<i>Leah, Lily of Killarney.</i></a>", 1)
}

def fix_oxen(b) {
    b.replace("printed and bound at the <a", "printed and bound at the</a> <a", 1)
}

def fix_eumaeus(b) {
    b.replace("&deg 9", "&deg; 9", 1)
}

def fix_penelope(b) {
    b.replace("enteric fever<a id=\"010058bloodyswindle10\" class=\"box-images\" href=\"notes/010058bloodyswindle.htm\"> he", "enteric fever he", 1);
    b.replace("evening we kissed goodbye <a", "evening we kissed goodbye</a> <a", 1);
}

def fix_mismatches(b, chapter) {
    fix_basics(b);
    b.start_of_buffer();
    var ch_num = to_string(chapter+1);
    if(ch_num == "3") {
	b.replace("[3]", "[ 3 ]", 1);
    } else {
	b.replace("<font size=\"+2\">["+ch_num+"]</font>", "[ "+ch_num+" ]", 1);
    }
    switch(chapter) {
    case (0)  {fix_telem(b);	break;}
    case (2)  {fix_proteus(b);	break;}
    case (12) {fix_nausicaa(b); break;}
    case (13) {fix_oxen(b);	break;}
    case (15) {fix_eumaeus(b);  break;}
    case (17) {fix_penelope(b); break;}
    }
    join_repeated_links(b, "</a> <a", " ");
    join_repeated_links(b, "</a><a", " ");
    // join_repeated_links(b, "</a> </p> <p> <a", " </p> <p> ");
    join_repeated_italics(b);
    b.start_of_buffer();
}

def cleanup_note(note_b) {
    note_b.start_of_buffer();
    while(note_b.find("<a") >= 0) {
	note_b.backward(2);
	note_b.set_mark();
	note_b.find(">");
	note_b.erase_region();
    }
    note_b.start_of_buffer();
    note_b.replace("</a>", "");

    note_b.start_of_buffer();
    note_b.replace("<em><em>", "<em>");

    note_b.start_of_buffer();
    note_b.replace("</em></em>", "</em>");
    
    note_b.start_of_buffer();
    note_b.replace("<br>", "");
    
    note_b.start_of_buffer();
    note_b.replace("—", "&mdash;")

    // somefiles seem to have extra nested divs
    note_b.start_of_buffer();
    note_b.replace("<div id=\"note2\">", "");
    note_b.replace("<div id=\"note\">", "");
    note_b.replace("<div>", "");
    note_b.replace("</div>", "");

    note_b.start_of_buffer();
    if (note_b.find(regex("<p[ >]")) < 0) {
	note_b.paste("<p>");
	note_b.end_of_buffer();
	note_b.paste("</p>");
    }
    note_b.start_of_buffer();
    if (note_b.find("</p>") < 0) {
	note_b.end_of_buffer();
	note_b.paste("</p>");
    }

    note_b.start_of_buffer();
    if (note_b.find("<meta") >= 0) {
	note_b.backward(5);
	note_b.set_mark();
	note_b.find(">");
	note_b.erase_region();
    }
    note_b.start_of_buffer();
    note_b.replace("</meta>", "");
}

def add_to_notes_map(notes_index, title, url) {
    var letter = to_string(title.at(0));

    var t = to_string(title);

    if (notes_index.count(letter) == 0) {
	notes_index[letter] = Map();
    }
    notes_index[letter][t] = url;
}

def insert_footnote(filename, note_id, note_ref_id, epub, notes_index) {
    var note_b = buffer(basepath + "/" + filename);
    if(note_b.empty()) {
	return false;
    }
    var title = "(title unknown)";
    if(note_b.find("<title>") >= 0) {
	note_b.set_mark();
	if (!note_b.goto_pos(note_b.find("</title>"))) {
	    print("error: title end tag not found: " + filename);
	    return false;
	}
	title = to_string(note_b.copy());
	add_to_notes_map(notes_index, note_b.copy(), filename);
    } else {
	print("warning: unable to find title for note: " + filename);
    }
    if(note_b.find("<div id=\"note\">") < 0) {
	print("error: couldn't find starting point of note: " + filename);
	return false;
    }
    note_b.set_mark();
    note_b.goto_pos(note_b.find("</div>"));
    note_b.narrow_to_region();

    cleanup_note(note_b);

    note_b.start_of_buffer();
    var title_with_id = title;
    if (!note_id.empty()) {
	title_with_id = note_id + ". " + title;
    }
    note_b.paste("<font size=\"+1\"><em>" + title_with_id + "</em></font>\n");
    note_b.end_of_buffer();
    note_b.rfind("</p>");
    note_b.paste(" <a href=\"#jpref" + note_ref_id +"\" role=\"doc-backlink\" title=\"Go to note reference\">⤶</a>")
    var note = note_b.get_contents();
    var extended_note_found = true;
    note_b.end_of_buffer();
    note_b.widen();
    if(note_b.find(regex("<div id=\"expandednote\".*>")) < 0) {
	print("error: couldn't find extended note: " + filename);
	extended_note_found = false;
    }
    note_b.set_mark();
    note_b.find("<div id=\"button\"");
    if (extended_note_found && note_b.copy().empty()) {
	print("error: couldn't fine end of extended note: " + filename);
	extended_note_found = false;
    }

    if (!extended_note_found) {
	epub.paste("<div role=\"doc-footnote\" epub:type=\"footnote\" id=\"jpnote" + note_ref_id + "\">"+
		   note +
		   "Back to <a href=\"#jpref" + note_ref_id +"\" role=\"doc-backlink\" title=\"Go to note reference\">text</a>.</div><hr/>\n");
	return true;
    }
    note_b.rfind("</div>");
    note_b.narrow_to_region();

    cleanup_note(note_b);

    note_b.start_of_buffer();

    // remove signature block if present
    if(note_b.goto_pos(note_b.find("<div id=\"return\">"))) {
	note_b.set_mark();
	note_b.find("</div>");
	note_b.erase_region();
    } else if(note_b.goto_pos(note_b.find(regex("<p>JH 20[0-9][0-9]</p>")))) {
	note_b.set_mark();
	note_b.find("</p>");
	note_b.erase_region();
    }

    var extended_note = note_b.get_contents();

    epub.paste("<div role=\"doc-footnote\" epub:type=\"footnote\" id=\"jpnote" + note_ref_id + "\">"+
	       note + "<br/><u><em>Read more</em></u>" +
	       extended_note +
	       "Back to <a href=\"#jpref" + note_ref_id +"\" role=\"doc-backlink\" title=\"Go to note reference\">text</a>.</div><hr/>\n");

    return true;
}

def add_epub_namespace(epub) {
    epub.find("1999/xhtml\"");
    epub.paste(" xmlns:epub=\"http://www.idpf.org/2007/ops\"");
}

def update_css(epub) {
    epub.find("p {");
    epub.next_line();
    epub.paste("p.pagebreak { page-break-after:always; }\n");
    epub.paste("p.firstpage {text-align: justify; margin-top: 1em; margin-bottom: 1em; text-indent: 0;}\n");
    epub.paste("p.preface { margin-bottom: 1.3em; }");
    epub.paste("p.preface-li { text-indent: 0; margin-bottom: 1.3em; }");
    epub.replace(".toc       { margin-left: 1%", ".toc       { margin-left: 0");
}

def replace_first_page(epub, date) {
    epub.goto_pos(epub.find("<pre xml:space=\"preserve\">"));
    epub.set_mark();
    epub.find("</pre>");
    epub.erase_region();

    var firstpage = buffer("firstpage.htm");
    firstpage.replace("%lastupdated%", date);
    epub.paste(firstpage.get_contents());
    epub.paste(pagebreak);
}

def update_author_formatting(epub) {
    epub.replace("<p class=\"title3\">Ulysses</p>", "<p class=\"title3\"><em>Ulysses</em></p>");
    var author_start = epub.find_fuzzy("<h2> by James Joyce </h2>");
    epub.set_mark();
    epub.goto_pos(author_start);
    epub.erase_region();
    epub.paste("<h3>by James Joyce</h3>");
    epub.find("<hr />");
    epub.paste(pagebreak);
}

def update_toc(epub) {
    epub.find("<div class=\"toc\">");
    epub.paste("<a href=\"#link2H_4_preface\"> Preface </a><br /><br />");

    epub.find("[ 18 ]");
    epub.find("</div>");
    epub.paste("<br /> <div style=\"text-align: center;\">");
    epub.paste("<a href=\"#link2H_4_annotations\"> Annotations </a><br />");
    epub.paste("<a href=\"#link2H_4_index_titles\"> Index of Titles </a><br /></div>");

    epub.find("<hr />");
    epub.paste(pagebreak);
}

def insert_preface(epub) {
    epub.find("<a name=\"link2H_4_0001\" id=\"link2H_4_0001\">");
    epub.rfind("<p>");
    epub.paste(buffer("preface.htm").get_contents());
    epub.paste(pagebreak);
}

def prepare_notes_cursor(epub, notes_cur) {
    // move notes_cur to end of novel text. notes will be inserted there.
    epub.use_cursor(notes_cur);
    epub.find("End of the Project Gutenberg EBook of Ulysses, by James Joyce");
    epub.rfind("<pre");
    epub.set_mark();
    epub.find("</pre>");
    epub.erase_region();
    var end_pos = epub.get_pos();
    epub.paste(pagebreak + "\n\n<h2>Annotations</h2>");
    epub.paste("<a name=\"link2H_4_annotations\" id=\"link2H_4_annotations\"> </a>\n")
    return end_pos;
}

def prepare_main_cursor(epub, main_cur, end_pos) {
    epub.use_cursor(main_cur);

    // go just before start of first chapter.
    epub.find("<a name=\"link2HCH0001\" id=\"link2HCH0001\">");
    epub.set_mark();
    epub.goto_pos(end_pos);
    epub.narrow_to_region(); // so that we don't match with text that we added as footnotes.
    epub.start_of_buffer();  // goes to start of narrowed region.
}

def penelope_reorder(epub) {
    epub.find("they hide it with a cabbageleaf");
    epub.set_mark();
    epub.find("kick or a bang of something there");
    var passage_to_move = epub.cut();
    // print(passage_to_move);
    epub.set_mark();
    epub.find("go about like that I asked him");
    // print("\n\n" + epub.copy())
    epub.paste(passage_to_move);
    epub.start_of_buffer();
}


def add_notes(epub, main_cur, notes_cur, use_colour) {
    var total = 0;
    var found = 0;
    var not_found = 0;

    var colours;

    if (use_colour) {
	colours = parse_colours();
    }

    var notes_index = Map();

    for (var chapter = 0; chapter < 18; ++chapter) {
	var b = buffer(basepath+chapters[chapter]);

	epub.use_cursor(notes_cur);
	epub.paste(pagebreak + "<h3>[ " + to_string(chapter+1) + " ]</h3>");

	var note_num = 1;

	fix_mismatches(b, chapter);

	b.find("class=\"newchapter\"");
	b.find(">");
	b.set_mark();
	b.find("<div id=\"footer\">");
	b.narrow_to_region();  // the chapter pages have <a> tags after the contents, keep them out.
	b.start_of_buffer();
	while(b.find("href=\"") >= 0) {
	    b.set_mark();
	    b.goto_pos(b.find("\""));
	    var url = b.copy();

	    b.find(">");
	    b.set_mark();
	    b.goto_pos(b.find("</a>"));
	    var text = b.copy();
	    var eol = b.get_pos();
	    
	    b.goto_pos(b.rfind("id=\""));
	    b.set_mark();
	    b.goto_pos(b.find("\""));
	    var note_name = to_string(b.copy());
	    
	    b.goto_pos(eol);
	    total += 1;
	    epub.use_cursor(main_cur);

	    if(epub.find_fuzzy(text) >= 0) {
		var note_str = to_string(note_num);
		var note_ref_str = to_string(found)
		epub.use_cursor(notes_cur);
		if(insert_footnote(url, note_str, note_ref_str, epub, notes_index)) {
		    epub.use_cursor(main_cur);
		    if(use_colour && colours.count(note_name) > 0) {
			epub.paste("<sup><a id=\"jpref"+note_ref_str+"\" style=\"color:"+colours[note_name]+"\" role=\"doc-noteref\" epub:type=\"noteref\" href=\"#jpnote" +note_ref_str+ "\">"+note_str+"</a></sup>");
		    } else {
			epub.paste("<sup><a id=\"jpref"+note_ref_str+"\" role=\"doc-noteref\" epub:type=\"noteref\" href=\"#jpnote" +note_ref_str+ "\">"+note_str+"</a></sup>");
		    }
		    found += 1;
		    note_num += 1;
		} else {
		    print("annotation_failed-"+chapters[chapter] + ": " + text)
		}
		// print("text found: (" + chapters[chapter] + ") " + text);
	    } else {
		print("text_not_found-" + chapters[chapter] + ": " + text);
		not_found += 1;
	    }
	}
    }
    print("total:" + to_string(total))
    print("found:" + to_string(found))
    print("not_found:" + to_string(not_found))

    return notes_index;
}

def add_notes_index(epub, notes_index, index_cur, notes_cur) {
    epub.use_cursor(index_cur);
    epub.paste(pagebreak);
    epub.paste("<h2>Index of Titles</h2>");
    epub.paste("<a name=\"link2H_4_index_titles\" id=\"link2H_4_index_titles\"> </a>\n")
    epub.paste("<p>All of the notes posted so far are listed here alphabetically by title. Click to go directly to a note without locating its appearances in the text of the novel.</p>")

    epub.use_cursor(notes_cur);
    epub.paste(pagebreak);
    epub.paste("<h3>Titles</h3>");

    epub.use_cursor(index_cur);
    var count = 0;
    for (letter : notes_index) {
	if (letter.first == "Ü") {
	    continue
	}
	// print(letter.first)
	epub.paste("<h3>" + letter.first + "</h3>");

	var notes = Vector();
	if (letter.first == "U") {
	    for (note : notes_index["Ü"]) {
		notes.push_back(note);
	    }
	}

	for (note : letter.second) {
	    notes.push_back(note);
	}
	for (note : notes) {
	    var note_ref_str = "iot-" + to_string(count);
	    // print(note.first);
	    epub.use_cursor(notes_cur);
	    
	    if(insert_footnote(note.second, "", note_ref_str, epub, Map())) {
		epub.use_cursor(index_cur);
		epub.paste("<a id=\"jpref"+note_ref_str+"\" role=\"doc-noteref\" epub:type=\"noteref\" href=\"#jpnote" +note_ref_str+ "\">"+note.first+"</a><br />");
		++count;
	    }
	}
    }
    print("distinct_notes: " + to_string(count))
}

def make_epub(use_colours, args, outfile) {
    basepath = args.anno_path;

    var epub = buffer(args.infile, must_open);
    var main_cur = epub.new_cursor();
    var notes_cur = epub.new_cursor();
    var index_cur = epub.new_cursor();

    epub.use_cursor(main_cur);

    add_epub_namespace(epub);
    update_css(epub);
    replace_first_page(epub, args.date);
    update_author_formatting(epub);
    update_toc(epub);
    insert_preface(epub);

    var end_pos = prepare_notes_cursor(epub, notes_cur);
    prepare_main_cursor(epub, main_cur, end_pos);
    penelope_reorder(epub);

    var notes_index = add_notes(epub, main_cur, notes_cur, use_colours);

    epub.use_cursor(notes_cur);
    var notes_cur_pos = epub.get_pos();
    
    epub.use_cursor(index_cur);
    epub.goto_pos(notes_cur_pos);
    
    add_notes_index(epub, notes_index, index_cur, notes_cur);

    epub.save_as(outfile)
}

def main() {
    var args = parseargs();
    make_epub(false, args, args.outfile)
    make_epub(true, args, args.colour_outfile)
}

main()
